OBSOLETE United patch for the three filesystem methods to support split-rooting
See http://wiki.openindiana.org/oi/Advanced+-+Split-root+installation
Copyright (C) 2013 by Jim Klimov, License: CDDL

--- /lib/svc/method/fs-minimal.orig-oi_151a8	2013-07-21 16:35:53.000000000 +0200
+++ /lib/svc/method/fs-minimal	2013-11-18 20:41:27.498150952 +0100
@@ -31,6 +31,10 @@
 . /lib/svc/share/smf_include.sh
 . /lib/svc/share/fs_include.sh
 
+# Report selected mounts to /dev/msglog
+debug_mnt=0
+[ -f /.debug_mnt ] && debug_mnt=1
+
 # Mount other file systems to be available in single user mode.
 # Currently, these are /var, /var/adm, /var/run and /tmp.  A change
 # here will require a modification to the following programs (and
@@ -49,6 +53,7 @@
 	if [ -n "$mountp" ]; then
 		mounted $mountp $mntopts $fstype < /etc/mnttab && continue
 		checkfs $fsckdev $fstype $mountp || exit $SMF_EXIT_ERR_FATAL
+		[ x"$debug_mnt" = x1 ] && echo "Mounting '$fs': use '$mountp' of type '$fstype' with opts '$mntopts' from vfstab" > /dev/msglog
 		mountfs -O $mountp $fstype $mntopts - ||
 		    exit $SMF_EXIT_ERR_FATAL
 		continue
@@ -57,10 +62,50 @@
 		mountpt=`zfs get -H -o value mountpoint $be$fs 2>/dev/null`
 		if [ $? = 0 ] ; then
 			if [ "x$mountpt" = "x$fs" ] ; then
+				[ x"$debug_mnt" = x1 ] && echo "Mounting '$fs': use '$be$fs': in same root hierarchy" > /dev/msglog
 				/sbin/zfs mount -O $be$fs
+				continue
 			fi
 		fi
-	fi
+		# These mountpoints can be shared among BEs in a separate tree.
+		# Find and mount matching automountable datasets; if there is
+		# choice - prefer the (first found?) one in the current rpool.
+		mountdslist="`zfs list -H -o canmount,mountpoint,name | awk '( $1 == "on" && $2 == "'"$fs"'" ) {print $3}' 2>/dev/null`"
+		if [ $? = 0 -a "x$mountdslist" != x ] ; then
+			if [ "x`echo "$mountdslist"|wc -l|sed 's/ //g'`" = x1 ]; then
+				# We only had one hit
+				[ x"$debug_mnt" = x1 ] && echo "Mounting '$fs': use '$mountdslist': the only option" > /dev/msglog
+				/sbin/zfs mount -O "$mountdslist"
+				continue
+			else
+				rpoolname="`echo "$be" | awk -F/ '{print $1}'`"
+			        mountdspref="`echo "$mountdslist" | egrep '^'"$rpoolname/" | head -1`"
+				if [ $? = 0 -a "x$mountdspref" != x ] ; then
+					[ x"$debug_mnt" = x1 ] && echo "Mounting '$fs': use '$mountdspref': same rpool" > /dev/msglog
+					/sbin/zfs mount -O "$mountdspref"
+					continue
+				fi
+				# This is the least-definite situation: several
+			        # matching datasets exist, and none on the current
+				# rpool. See if any pools can be ruled out due to
+			        # bad (non-default) altroots.
+				for mountds in $mountdslist; do
+					dspool="`echo "$mountds" | awk -F/ '{print $1}'`"
+					dspool_altroot="`zpool list -H -o altroot "$dspool"`"
+					if [ $? = 0 -a \
+					     x"$dspool_altroot" = "x-" -o \
+					     x"$dspool_altroot" = "x/" ]; then
+						[ x"$debug_mnt" = x1 ] && echo "Mounting '$fs': use '$mountds': good altroot" > /dev/msglog
+					        /sbin/zfs mount -O "$mountds"
+						continue
+					fi
+				    done
+				fi
+		fi
+		# Technically, it is possible to have a pool named var with
+		# the default altroot and a dataset "var/adm" with an inherited
+		# mountpoint, which should automount into "/var/adm". TBD...
+	fi  ### if root is ZFS
 done
 
 mounted /var/run - tmpfs < /etc/mnttab
@@ -73,11 +118,17 @@
 fi
 
 if [ "$rootiszfs" = 1 ] ; then
+	_SKIP=0
+	# Mount (other) possible children of current rootfs dataset
 	/sbin/zfs list -rH -o mountpoint -s mountpoint -t filesystem $be | \
 	    while read mountp ; do
+		# Skip the rootfs itself regardless of its mountpoint name
+		[ "$_SKIP" = 0 ] && _SKIP=1 && continue
+
 		if [ "x$mountp" != "x" -a "$mountp" != "legacy" ] ; then
 			mounted $mountp - zfs < /etc/mnttab  && continue
-			/sbin/zfs mount $be$mountp
+			[ x"$debug_mnt" = x1 ] && echo "Mounting '$mountp': use '$be$mountp': in same root hierarchy" > /dev/msglog
+			/sbin/zfs mount -O "$be$mountp"
 		fi
 	done
 fi
--- /lib/svc/method/fs-root.orig-oi-hipster-20150917    2015-09-17 16:51:13.776281274 +0200
+++ /lib/svc/method/fs-root     2015-09-18 09:21:19.234858110 +0200
@@ -76,7 +76,8 @@
 readvfstab "/usr" < $vfstab
 if [ -n "$mountp" ]; then
 	if [ "$fstype" = zfs ]; then
-		mountfs - /usr $fstype $mntopts - || exit $SMF_EXIT_ERR_FATAL
+		mounted /usr - zfs < /etc/mnttab || \
+		{ mountfs - /usr $fstype $mntopts - || exit $SMF_EXIT_ERR_FATAL; }
 	else
 		#
 		# Must use -o largefiles here to ensure the
@@ -127,7 +128,7 @@
 	# if mountp = /usr, there is a non-legacy mount of /usr
 	# in the boot environment being booted.
 	#
-	if [ "x$mountp" = "x/usr" ] ; then
+	if [ "x$mountp" = "x/usr" ] && ! mounted /usr - zfs < /etc/mnttab ; then
 		/sbin/zfs mount $special/usr
 		if [ $? != 0 ] ; then
 				msg='zfs-mount failed'
--- /lib/svc/method/fs-usr.orig-oi_151a8	2013-07-21 16:35:53.000000000 +0200
+++ /lib/svc/method/fs-usr	2013-11-18 20:41:27.322644738 +0100
@@ -54,8 +54,14 @@
 	# If we have a dedicated dump device, then go ahead and configure it.
 	# 
 	if [ "x$special" != "x$DUMPADM_DEVICE" ]; then
-		if [ -x /usr/sbin/dumpadm -a -b $DUMPADM_DEVICE ]; then
-			/usr/sbin/dumpadm -u || exit $SMF_EXIT_ERR_CONFIG
+		if [ -x /usr/sbin/dumpadm ]; then
+			if [ -b $DUMPADM_DEVICE ]; then
+				/usr/sbin/dumpadm -u || \
+					exit $SMF_EXIT_ERR_CONFIG
+			fi
+		else
+			echo "WARN: /usr/sbin/dumpadm not found" >&2
+			return
 		fi
 	fi
 }
